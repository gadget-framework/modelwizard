library(r4ss)  # NB: This is to force shinyapps to register the dependency
# https://r4ss.github.io/r4ss/articles/r4ss-intro-vignette.html
# https://nmfs-stock-synthesis.github.io/doc/SS330_User_Manual_release.html

template_str <- function (s) {
    stringr::str_interp(s, parent.frame(1))
}
escape_sym <- Vectorize(function (s) deparse1(as.symbol(s), backtick = TRUE))

mw_ss_code_readxl <- function (sheet_name, xlsx) {
    if (!nzchar(xlsx)) return("")
    template_str('${escape_sym(sheet_name)} <- readxl::read_excel(data_path, ${deparse1(sheet_name)})\n')
}

mw_ss_code_header <- function (spec, xlsx) {
    mod_dir <- gsub('\\.xlsx$' , '-ss3', xlsx)

    template_str(r'(
library(r4ss)
library(reshape2)
library(readxl)

mod_path <- ${deparse1(mod_dir)}
data_path <- ${deparse1(xlsx)}

# parse_levels from gadget3
parse_levels <- function (lvls, var_name) {
    m <- suppressWarnings(as.numeric(lvls))
    if (!anyNA(m)) return(data.frame(
        names = lvls,
        lower_incl = TRUE,
        lower_bound = m,
        upper_bound = c(tail(m, -1), Inf),  # NB: No data about final bound, assume open-ended
        upper_incl = FALSE,
        open_ended_upper = TRUE,
        stringsAsFactors = FALSE))

    m <- regmatches(lvls, regexec("^(\\[|\\()(.*),(.*)(\\]|\\))", lvls))
    if (all(vapply(m, length, numeric(1)) == 5)) return(data.frame(
        names = lvls,
        lower_incl = vapply(m, function (mm) identical(mm[[2]], '['), logical(1)),
        lower_bound = vapply(m, function (mm) as.numeric(mm[[3]]), numeric(1)),
        upper_bound = vapply(m, function (mm) as.numeric(mm[[4]]), numeric(1)),
        upper_incl = vapply(m, function (mm) identical(mm[[5]], ']'), logical(1)),
        open_ended_upper = is.infinite(as.numeric(tail(m, 1)[[1]][[4]])),
        stringsAsFactors = FALSE))

    stop("Unknown form of ", var_name, " levels, see ?cut for formatting: ", paste(lvls, collapse = ", "))
}

# Create new SS3 model based on "simple_3.30.13"
r4ss::copy_SS_inputs(
    dir.old = system.file(file.path("extdata", "simple_3.30.13"), package = "r4ss"),
    dir.new = mod_path,
    overwrite = TRUE)
inputs <- r4ss::SS_read(dir = mod_path)

inputs$dat$Comments <- sprintf("#C %s model generated by ModelWizard", mod_path)

# Clear tables
inputs$dat$fleetinfo <- inputs$dat$fleetinfo[c(),,drop = FALSE]
inputs$dat$catch <- inputs$dat$catch[c(),,drop = FALSE]
inputs$dat$CPUEinfo <- inputs$dat$CPUEinfo[c(),,drop = FALSE]
inputs$dat$CPUE <- inputs$dat$CPUE[c(),,drop = FALSE]
inputs$dat$len_info <- inputs$dat$len_info[c(),,drop = FALSE]
inputs$dat$lencomp <- inputs$dat$lencomp[c(),,drop = FALSE]
inputs$dat$age_info <- inputs$dat$age_info[c(),,drop = FALSE]
inputs$dat$agecomp <- inputs$dat$agecomp[c(),,drop = FALSE]
inputs$dat$MeanSize_at_Age_obs <- inputs$dat$MeanSize_at_Age_obs[c(),,drop = FALSE]
)')}

mw_ss_code_area <- function (spec) {
    area_count <- length(spec$area)
    template_str(r'(
# Create area definitions ####################
inputs$dat$N_areas <- ${deparse1(area_count)}
)')}

mw_ss_code_time <- function (r, spec) {
    year_max <- as.integer(r$year_max)
    year_min <- as.integer(r$year_min)
    steps_count <- as.integer(r$steps)
    step_lengths <- rep(as.integer(12 / steps_count), steps_count)

    template_str(r'(
# Create time definitions ####################

inputs$dat$styr <- ${deparse1(year_min)}

inputs$dat$endyr <- ${deparse1(year_max)}
inputs$dat$nseas <- ${deparse1(steps_count)}
inputs$dat$months_per_seas <- ${deparse1(step_lengths[[1]])}
)')}

mw_ss_code_stock <- function (r, spec, xlsx) {
    if (nrow(spec$stock) > 1) stop("Only one stock supported, got: ", paste(spec$stock$name))

    template_str(r'(
# Create stock definition for ${r$name} ####################

inputs$dat$spawn_month <- ${deparse1(max(as.numeric(r$renewal_step) - 1, 0))} * inputs$dat$months_per_seas
inputs$dat$Nsexes <- 1
inputs$dat$Nages <- ${deparse1(r$age_max - r$age_min + 1)}
inputs$dat$lbin_vector <- seq(${deparse1(r$lg_min)}, ${deparse1(r$lg_max)}, ${deparse(r$lg_size)})
inputs$dat$agebin_vector <- seq(${deparse1(r$age_min)}, ${deparse1(r$age_max)}, 1)
)')}


mw_ss_code_fleet <- function (r, spec, xlsx) {
    fleet_sym <- escape_sym(paste0('fleet_', r$name))
    area_names <- spec$area$name
    stock_list <- lapply(spec$stock$name, as.symbol)
    data_name <- paste("landings", r$name, sep = "_")
    data_sym <- escape_sym(data_name)

    template_str(r'(
# Create fleet definition for ${r$name} ####################
inputs$dat$fleetinfo <- rbind(inputs$dat$fleetinfo, data.frame(
    type = 1,  # Fleet with input catches
    surveytiming = ${deparse1(as.numeric(r$step_active) - 1)} * inputs$dat$months_per_seas,
    area = 1,  # Assume one area
    units = ${if (r$landings == "weight") "1,  # Biomass (metric tons)" else "2,  # Numbers (thousands of fish)"}
    need_catch_mult = 0,
    fleetname = ${deparse1(r$name)},
    stringsAsFactors = FALSE))

inputs$dat$len_info[${deparse1(r$name)},] <- list(
    mintailcomp = 0,
    addtocomp = 1e-7,
    combine_M_F = 0,
    CompressBins = 0,
    CompError = 0,
    ParmSelect = 0,
    minsamplesize = 0.001)

inputs$dat$age_info[${deparse1(r$name)},] <- list(
    mintailcomp = 0,
    addtocomp = 1e-7,
    combine_M_F = 1,
    CompressBins = 0,
    CompError = 0,
    ParmSelect = 0,
    minsamplesize = 0.001)

# Equilibrium catch fields
inputs$dat$catch <- rbind(inputs$dat$catch, data.frame(
    year = -999,
    seas = seq_len(inputs$dat$nseas),
    fleet = ${deparse1(r$name)},  # NB: Use fleetnames for now, will renumber later
    catch = 0,
    catch_se = 0.01,
    stringsAsFactors = TRUE))

${mw_ss_code_readxl(data_name, xlsx)}
inputs$dat$catch <- rbind(inputs$dat$catch, data.frame(
    year = ${data_sym}$year,
    seas = ${data_sym}$step,
    fleet = ${deparse1(r$name)},  # NB: Use fleetnames for now, will renumber later
    catch = ${data_sym}[[${deparse1(r$landings)}]],
    catch_se = 0.01,
    stringsAsFactors = TRUE))
)')}

mw_ss_code_abund <- function (r, spec, xlsx) {
    fleet_sym <- escape_sym(r$name)
    stock_list <- lapply(spec$stock$name, as.symbol)

    if (r[['dist']] == 'none') return("")
    if (r[['aldist']] != 'none') stop("Age-length distribution for abundance indices not supported: ", r$name)

    cpue_name <- unname(paste('dist', r$name, sep = "_"))
    cpue_sym <- escape_sym(cpue_name)
    
    template_str(r'(
# Create abundance index for ${r$name} ####################
inputs$dat$fleetinfo <- rbind(inputs$dat$fleetinfo, data.frame(
    type = 3,
    surveytiming = ${deparse1(as.numeric(r$step_active) - 1)} * inputs$dat$months_per_seas,
    area = 1,  # Assume one area
    units = ${if (r$dist == "weight") "1,  # Biomass (metric tons)" else "2,  # Numbers (thousands of fish)"}
    need_catch_mult = 0,
    fleetname = ${deparse1(r$name)}))

inputs$dat$len_info[${deparse1(r$name)},] <- list(
    mintailcomp = 0,
    addtocomp = 1e-7,
    combine_M_F = 0,
    CompressBins = 0,
    CompError = 0,
    ParmSelect = 0,
    minsamplesize = 0.001)

inputs$dat$age_info[${deparse1(r$name)},] <- list(
    mintailcomp = 0,
    addtocomp = 1e-7,
    combine_M_F = 1,
    CompressBins = 0,
    CompError = 0,
    ParmSelect = 0,
    minsamplesize = 0.001)

inputs$dat$CPUEinfo[${deparse1(r$name)},] <- list(
    Fleet = ${deparse1(r$name)},  # NB: Use fleetnames for now, will renumber later
    Units = ${if (r$dist == "weight") "1,  # Biomass (metric tons)" else "0,  # Numbers (thousands of fish)"}
    Errtype = 0,
    SD_Report = 0)

${mw_ss_code_readxl(cpue_name, xlsx)}
inputs$dat$CPUE <- rbind(inputs$dat$CPUE, data.frame(
    year = ${cpue_sym}$year,
    seas = ${cpue_sym}$step,
    index = ${deparse1(r$name)},  # NB: Use fleetnames for now, will renumber later
    obs = ${cpue_sym}[[${deparse1(r$dist)}]],  # TODO: Do we need to scale if numbers?
    se_log = 0.3,
    stringsAsFactors = TRUE))
)')}

mw_ss_code_ldist <- function (r, spec, xlsx) {
    fleet_sym <- escape_sym(r$name)
    stock_list <- lapply(spec$stock$name, as.symbol)

    if (r[['ldist']] == 'none') return("")

    ldist_name <- unname(paste('ldist', r$name, sep = "_"))
    ldist_sym <- escape_sym(ldist_name)
    
    template_str(r'(
# Create length distribution for ${r$name} ####################

${mw_ss_code_readxl(ldist_name, xlsx)}

if (nrow(inputs$dat$lencomp) == 0) {
    # Seed lencomp with columns based on lbin_vector
    cols <- paste0("L", inputs$dat$lbin_vector)
    cols <- structure(as.list(rep(0, length(cols))), names = cols)
    inputs$dat$lencomp <- as.data.frame(c(list(
        Yr = 1999,
        Seas = 1,
        FltSvy = "",
        Gender = 0,
        Part = 0,
        NSamp = 100), cols))[c(),]
}

# Convert lengths into SS-compatible names
${ldist_sym}$length <- as.factor(${ldist_sym}$length)
lvls <- parse_levels(levels(${ldist_sym}$length))
lvls_map <- structure(paste0("L", lvls$lower_bound), names = lvls$names)
levels(${ldist_sym}$length) <- lvls_map[levels(${ldist_sym}$length)]

# Rotate length groupings, renaming to SS labels
${ldist_sym} <- reshape2::dcast(
    ${ldist_sym},
    year + step + area ~ length,
    value.var = ${deparse1(r$ldist)})

inputs$dat$lencomp <- dplyr::bind_rows(inputs$dat$lencomp, cbind(data.frame(
    Yr = ${ldist_sym}$year,
    Seas = ${ldist_sym}$step,
    FltSvy = ${deparse1(r$name)},  # NB: Use fleetnames for now, will renumber later
    Gender = 0,
    Part = 0,
    NSamp = 100,
    stringsAsFactors = TRUE), ${ldist_sym}[,lvls_map]))
)')}

mw_ss_code_aldist <- function (r, spec, xlsx) {
    fleet_sym <- escape_sym(r$name)
    stock_list <- lapply(spec$stock$name, as.symbol)

    if (r[['aldist']] == 'none') return("")

    template_str(r'(
# Create age-length distribution for ${r$name} ####################
# TODO: Not supported yet
)')}

mw_ss_code_footer <- function(spec, xlsx) {
    fleet_syms <- vapply(spec$fleet$name, function (r_name) escape_sym(paste0('fleet_', r_name)), character(1))
    abund_syms <- vapply(spec$abund$name, function (r_name) escape_sym(paste0('abund_', r_name)), character(1))

    template_str(r'(
# Finalise model #######################

# Convert names to numbered fleets
inputs$dat$catch$fleet <- as.numeric(factor(inputs$dat$catch$fleet, levels = inputs$dat$fleetinfo$fleetname))
inputs$dat$CPUEinfo$Fleet <- as.numeric(factor(inputs$dat$CPUEinfo$Fleet, levels = inputs$dat$fleetinfo$fleetname))
inputs$dat$CPUE$index <- as.numeric(factor(inputs$dat$CPUE$index, levels = inputs$dat$fleetinfo$fleetname))
inputs$dat$lencomp$FltSvy <- as.numeric(factor(inputs$dat$lencomp$FltSvy, levels = inputs$dat$fleetinfo$fleetname))

# Set rownames (so they can be added as comments into data.ss)
rownames(inputs$dat$fleetinfo) <- inputs$dat$fleetinfo$fleetname

# Zero NA values in catch
for (n in names(inputs$dat$lencomp)[-seq_len(6)]) {
    inputs$dat$lencomp[[n]][is.na(inputs$dat$lencomp[[n]])] <- 0
}

# Derived values
inputs$dat$Nfleets <- nrow(inputs$dat$fleetinfo)
inputs$dat$N_lbins <- length(inputs$dat$lbin_vector)
if (nrow(inputs$dat$lencomp) > 0) {
    inputs$dat$use_lencomp <- 1
} else {
    inputs$dat$use_lencomp <- 0
    inputs$dat$lencomp <- NULL  # r4ss wont write 0-row data.frames
}
inputs$dat$N_agebins <- length(inputs$dat$agebin_vector)
if (nrow(inputs$dat$MeanSize_at_Age_obs) > 0) {
    inputs$dat$use_MeanSize_at_Age_obs <- 1
} else {
    inputs$dat$use_MeanSize_at_Age_obs <- 0
    inputs$dat$MeanSize_at_Age_obs <- NULL  # r4ss wont write 0-row data.frames
}
inputs$dat$Ngenders <- inputs$dat$Nsexes

# Write back to mod_path
r4ss::SS_write(inputs, dir = mod_path, overwrite = TRUE)
)')}

mw_ss_script <- function (
        spec,
        xlsx = "",
        compile = FALSE,
        run = FALSE) {
    stopifnot(is.list(spec) || is.environment(spec))
    stopifnot(length(intersect(names(spec), c("abund", "area", "fleet", "stock", "time"))) == 5)

    # Run fn(row, ...) for each row in tbl
    row_apply <- function (tbl, fn, ...) vapply(
        seq_len(nrow(tbl)),
        function (i) fn(as.list(tbl[i,, drop = FALSE]), ...),
        character(1))

    paste(c(
        mw_ss_code_header(spec, xlsx),
        mw_ss_code_area(spec),
        row_apply(spec$time, mw_ss_code_time, spec),
        row_apply(spec$stock, mw_ss_code_stock, spec, xlsx),
        row_apply(spec$fleet, mw_ss_code_fleet, spec, xlsx),
        row_apply(spec$abund, mw_ss_code_abund, spec, xlsx),
        row_apply(spec$fleet, mw_ss_code_ldist, spec, xlsx),
        row_apply(spec$abund, mw_ss_code_ldist, spec, xlsx),
        row_apply(spec$fleet, mw_ss_code_aldist, spec, xlsx),
        row_apply(spec$abund, mw_ss_code_aldist, spec, xlsx),
        mw_ss_code_footer(spec, xlsx),
# TODO: Params
#        (if (compile) mw_ss_code_compile(spec, xlsx) else ""),
#        (if (run) mw_ss_code_run(spec) else ""),
        ""), collapse = "\n")
}
